<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pmt_analysis.analysis.model_independent API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pmt_analysis.analysis.model_independent</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
from scipy.signal import savgol_filter
from tqdm import tqdm
from itertools import count
import warnings
from typing import Tuple, Union, Optional


class GainModelIndependent:
    &#34;&#34;&#34;Class for model independent occupancy and gain calculation.

    Calculation of the gain, i.e. the current amplification factor of the PMT, following the statistical
    method proposed in `Saldanha, R., et al. &#39;Model independent approach to the single photoelectron
    calibration of photomultiplier tubes.&#39; Nuclear Instruments and Methods in Physics Research Section A:
    Accelerators, Spectrometers, Detectors and Associated Equipment 863 (2017): 35-46`.

    Uses the peak area spectrum from pulsed low-intensity LED light illumination and LED triggered
    data taking. The fixed window analysis takes two data sets, one with LED &#39;off&#39;
    (practically pulsed at low enough voltage amplitude to ensure no light emission from the LED)
    and one with LED &#39;on&#39;, usually at a target occupancy (i.e. mean number photo electrons released
    per LED trigger) of ca. 2 for uncertainty minimization.

    Attributes:
        areas_led_on: Array with &#39;LED on&#39; data pulse areas.
        areas_led_off: Array with &#39;LED off&#39; data pulse areas.
        verbose: Verbosity of the output.
        outliers_thresholds: Range of area values used for the time dependent gain calculation.
    &#34;&#34;&#34;

    def __init__(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray, verbose: bool = False,
                 trim_outliers_bool: bool = True):
        &#34;&#34;&#34;Init of the GainModelIndependent class.

        Cleans and prepares the pulse area data inputs.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.
            verbose: Verbosity of the output.
            trim_outliers_bool: Remove outliers from input data using the `get_outlier_bounds` method.
        &#34;&#34;&#34;
        self.verbose = verbose
        # Bring pulse area data inputs to numpy.ndarray format
        self.areas_led_on = self.inputs_to_numpy(areas_led_on)
        self.areas_led_off = self.inputs_to_numpy(areas_led_off)
        # Remove outlier values
        self.outliers_thresholds = (None, None)
        if trim_outliers_bool:
            if verbose:
                print(&#39;Calculating range of area values to be used for the time dependent gain calculation.&#39;)
            outlier_bound_lower, outlier_bound_upper = self.get_outlier_bounds(self.areas_led_on, self.verbose)
            self.outliers_thresholds = (outlier_bound_lower, outlier_bound_upper)
            if verbose:
                print(&#39;Trimming area outliers with limits [{}, {}].&#39;.format(outlier_bound_lower, outlier_bound_upper))
            self.areas_led_off = self.areas_led_off[(self.areas_led_off &gt;= outlier_bound_lower)
                                                    &amp; (self.areas_led_off &lt;= outlier_bound_upper)]
            self.areas_led_on = self.areas_led_on[(self.areas_led_on &gt;= outlier_bound_lower)
                                                  &amp; (self.areas_led_on &lt;= outlier_bound_upper)]

    @staticmethod
    def inputs_to_numpy(input_data: Union[np.ndarray, list, dict, pd.DataFrame, pd.Series]) -&gt; np.ndarray:
        &#34;&#34;&#34;Bring pulse area data inputs to numpy.ndarray format.

        Args:
            input_data: Input pulse area data.
                Allowed types: `numpy.ndarray, list, dict, pandas.DataFrame, pandas.Series`
        Returns:
            input_data: Input data converted to numpy.ndarray.
        &#34;&#34;&#34;
        if type(input_data) == np.ndarray:
            pass
        elif type(input_data) == list:
            input_data = np.asarray(input_data)
        elif type(input_data) == dict:
            if &#39;area&#39; not in input_data.keys():
                raise KeyError(&#39;No key name `area` found in provided dictionary `input_data`.&#39;)
            elif type(input_data[&#39;area&#39;]) == np.ndarray:
                input_data = input_data[&#39;area&#39;]
            elif type(input_data[&#39;area&#39;]) == list:
                input_data = np.asarray(input_data[&#39;area&#39;])
            else:
                raise TypeError(&#39;Unsupported type for `input_data`.&#39;)
        elif type(input_data) == pd.DataFrame:
            if &#39;area&#39; not in input_data.columns:
                raise KeyError(&#39;No column name `area` found in provided data frame `input_data`.&#39;)
            else:
                input_data = input_data[&#39;area&#39;].to_numpy()
        elif type(input_data) == pd.Series:
            input_data = input_data.to_numpy()
        else:
            raise TypeError(&#39;Unsupported type for `input_data`.&#39;)
        return input_data

    @staticmethod
    def get_outlier_bounds(input_data: np.ndarray, verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;Calculate boundaries for outlier rejection.

        Outliers may bias the model independent gain calculation due to their large lever and
        should hence be removed.
        Determined are the values at which the entries in a window of size based on square-root
        binning falls below a certain threshold.

        Args:
            input_data: Input pulse area data.
            verbose: Verbosity of the output.

        Returns:
            Tuple with upper and lower bound to be used for outlier rejection.
        &#34;&#34;&#34;
        window_width = np.ceil((np.percentile(input_data, 99.99) - np.percentile(input_data, 0.01))
                               / np.sqrt(input_data.shape[0]))
        window_width = 5*window_width
        window_counts_threshold = 1
        for i in tqdm(count(0), disable=not bool(verbose)):
            if len(input_data[(input_data &gt;= i) &amp; (input_data &lt; i + window_width)]) &lt;= window_counts_threshold:
                break
        outlier_bound_upper = i + window_width
        for i in tqdm(count(0), disable=not bool(verbose)):
            if len(input_data[(input_data &lt;= -i) &amp; (input_data &gt; -(i + window_width))]) &lt;= window_counts_threshold:
                break
        outlier_bound_lower = -(i + window_width)
        return outlier_bound_lower, outlier_bound_upper

    @staticmethod
    def get_area_histogram(input_data: np.ndarray, bin_width: int = 1,
                           limits: Optional[Tuple[int, int]] = None) -&gt; tuple:
        &#34;&#34;&#34;Function to generate area histogram with given bin width.

        Args:
            input_data: Input pulse area data.
            bin_width: Bin width.
            limits: Range of histogram bins.

        Returns:
            tuple(bins_centers, cnts): Tuple with bins centers and corresponding counts values.
        &#34;&#34;&#34;
        try:
            bin_width = int(bin_width)
        except Exception:
            raise TypeError(&#39;bin_width must be of type int.&#39;)
        if limits is not None:
            if len(limits) != 2:
                raise ValueError(&#39;Limits must be a tuple of length 2.&#39;)
            try:
                limits_lower = int(limits[0])
                limits_upper = int(limits[1])
            except Exception:
                raise TypeError(&#39;Entries of limits must be of type int.&#39;)
            bins_edges = np.arange(limits_lower - 0.5, limits_upper + 1.5, bin_width)
        else:
            bins_edges = np.arange(np.min(input_data) - 0.5, np.max(input_data) + 1.5, bin_width)
        bins_centers = (bins_edges[1:] + bins_edges[:-1]) / 2
        counts, _ = np.histogram(input_data, bins=bins_edges)
        return bins_centers, counts

    @staticmethod
    def get_moments(input_data: np.ndarray) -&gt; dict:
        &#34;&#34;&#34;Calculate moments relevant for model independent gains calculation.

        Args:
            input_data: Input pulse area data.

        Returns:
            Dictionary with moments relevant for model independent gains calculation.
        &#34;&#34;&#34;
        dict_moments = dict()
        dict_moments[&#39;mean&#39;] = np.mean(input_data)
        dict_moments[&#39;variance&#39;] = np.var(input_data)
        return dict_moments

    @staticmethod
    def sav_gol_smoothing(input_data: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Smooth `input_data` with Savitzky–Golay filter.

        Args:
            input_data: Input threshold dependent occupancy values.

        Returns:
            output_data: Savitzky–Golay filter smoothed input data.
        &#34;&#34;&#34;
        # Set length of the filter window
        num = len(input_data) - 1
        if num % 2 == 0:
            num = num - 1
        # Set order of the polynomial used to fit the samples
        order = 10
        order = min(order, num - 1)
        # Apply filter
        output_data = savgol_filter(input_data, num, order)
        return output_data

    def get_occupancy_model_independent(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray) -&gt; dict:
        &#34;&#34;&#34;Calculate the occupancy for the model independent gain calculation.

        For a range of thresholds within the 0PE peak areas, calculate the number of entries
        below threshold for &#39;LED off&#39; (`integral_b`) and &#39;LED on&#39; (`integral_s`) data areas.
        The occupancy can be estimated from the number of &#39;LED on&#39; sample triggers with
        zero LED-induced photoelectrons, as can be assumed for a sufficiently low threshold
        for `integral_s`, and the total number of sample triggers, as can be by proportion estimated
        through `integral_b`. As the number of photoelectrons produced follows a Poisson distribution,
        we can use the expression `-ln(integral_s/integral_b)` as an estimator for the occupancy for the
        selected threshold. This threshold is supposed to be sufficiently low such that `integral_s` is
        not contaminated by a significant 1PE contribution. We therefore try to find the lowest
        threshold for which sufficient data points are available below threshold to achieve a
        relative occupancy error of below 1%. Ideally this is located in a local and global
        maximum plateau around / slightly below zero areas.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.

        Returns:
            occupancy_estimator: Dictionary with the following keys:
                {&#39;occupancy&#39;: final occupancy estimate;
                &#39;occupancy_err&#39;: uncertainty final occupancy estimate;
                &#39;threshold_occupancy_determination&#39;: threshold in 0PE peak area calculations
                    for final occupancy estimate;
                &#39;thr_occ_det_integral_fraction&#39;: fraction of entries in &#39;LED off&#39; data below threshold;
                &#39;tot_entries_b&#39;: total number of waveforms in &#39;LED off&#39; data,
                &#39;iterations&#39;: dictionary with the tested thresholds and corresponding
                    occupancy, occupancy uncertainty, and smoothed occupancy values}
        &#34;&#34;&#34;
        # Total number of waveforms in &#39;LED off&#39; data
        tot_entries_b = areas_led_off.shape[0]

        # Define list of thresholds to probe in iterative occupancy determination
        if self.outliers_thresholds[0] is None:
            thr_it_occ_det = np.abs(self.get_outlier_bounds(areas_led_on)[0])
        else:
            thr_it_occ_det = np.abs(self.outliers_thresholds[0])
        lower_thr_it_occ_det = - thr_it_occ_det / 2
        upper_thr_it_occ_det = thr_it_occ_det / 2
        list_thr_it_occ_det = np.arange(lower_thr_it_occ_det, upper_thr_it_occ_det + 1)

        # Initialize lists for resulting occupancies as a function of threshold.
        # Use lists with append as it showed to be faster than np.arrays in this application.
        occupancy_list = list()
        occupancy_err_list = list()
        thresholds_list = list()
        f_list = list()

        # Loop over thresholds and calculate corresponding occupancy and error
        for threshold in list_thr_it_occ_det:
            # Calculate number of entries below peak area threshold for &#39;LED off&#39; (integral_b) and
            # &#39;LED on&#39; (integral_s) data. Correction factor on integral_b (and later also f) should
            # be close to one and only correct for differences due to outlier removal.
            # If significantly different cardinalities of LED on and off data sets are used,
            # the error calculation below may become incorrect.
            integral_b = np.sum(areas_led_off &lt; threshold) * len(areas_led_on) / len(areas_led_off)
            integral_s = np.sum(areas_led_on &lt; threshold)

            # Perform occupancy calculations only for positive number of entries below threshold
            if integral_b &gt; 0 and integral_s &gt; 0:
                # Fraction of entries in &#39;LED off&#39; data below threshold
                f = integral_b / (tot_entries_b * len(areas_led_on) / len(areas_led_off))
                # The occupancy can be estimated from the number of &#39;LED on&#39; sample triggers with zero LED-induced
                # photoelectrons, as can be assumed for a sufficiently low threshold for integral_s, and the
                # total number of sample triggers, as can be by proportion estimated through integral_b.
                # As the number of photoelectrons produced follows a Poisson distribution, we can use the following
                # expression as an estimator for the occupancy for the selected threshold (which, if sufficiently low
                # to not be contaminated by a significant 1PE contribution,
                # should not change the obtained occupancy value).
                l_val = -np.log(integral_s / integral_b)
                l_err = np.sqrt((np.exp(l_val) + 1. - 2. * f) / integral_b)

                # Only consider occupancy values with relative uncertainties below 5%.
                if l_err / l_val &lt;= 0.05:
                    occupancy_list.append(l_val)
                    occupancy_err_list.append(l_err)
                    thresholds_list.append(threshold)
                    f_list.append(f)

        if len(occupancy_list) == 0:
            raise ValueError(&#39;No occupancy values determined in threshold iterations.&#39;)

        # Convert to numpy arrays
        occupancy_list = np.asarray(occupancy_list)
        occupancy_err_list = np.asarray(occupancy_err_list)
        thresholds_list = np.asarray(thresholds_list)
        f_list = np.asarray(f_list)

        # Smooth threshold-dependent occupancies with Savitzky–Golay filter
        occupancy_list_smooth = self.sav_gol_smoothing(occupancy_list)

        # Sort indices in smoothed occupancy list by their element value in descending order
        occupancy_list_smooth_argsort = occupancy_list_smooth.argsort()[::-1]

        # Find threshold and corresponding occupancy for highest smoothed occupancy value
        # for which the relative occupancy error is below 1%.
        # Ideally this is located in a local and global maximum plateau around / slightly below zero areas
        # where 1PE contributions are negligible but on the other hand sufficient data points are available
        # below the threshold to bring the relative uncertainty down to the required level.
        # If no threshold value fulfils this criterion, return NaN occupancy.
        occupancy_estimate = np.nan
        occupancy_estimate_err = np.nan
        threshold_occ_det = np.nan
        thr_occ_det_integral_fraction = np.nan
        for idx in occupancy_list_smooth_argsort:
            if occupancy_err_list[idx] / occupancy_list[idx] &lt; 0.01:
                occupancy_estimate = occupancy_list[idx]
                occupancy_estimate_err = occupancy_err_list[idx]
                threshold_occ_det = thresholds_list[idx]
                thr_occ_det_integral_fraction = f_list[idx]
                break

        if np.isnan(occupancy_estimate):
            warnings.warn(&#39;Failed to estimate occupancy with the required precision. Returned NaN.&#39;)
        elif occupancy_estimate &lt;= 0:
            warnings.warn(&#39;Warning: Estimated occupancy ({:.3f} ± {:.3f}) seems to be &#39;
                          &#39;less than zero.&#39;.format(occupancy_estimate, occupancy_estimate_err))
        elif self.verbose:
            print(&#39;Threshold for occupancy estimation: {}&#39;.format(threshold_occ_det))
            print(&#39;Estimated occupancy: {:.3f} ± {:.3f}&#39;.format(occupancy_estimate, occupancy_estimate_err))

        occupancy_estimator = {&#39;occupancy&#39;: occupancy_estimate,
                               &#39;occupancy_err&#39;: occupancy_estimate_err,
                               &#39;threshold_occupancy_determination&#39;: threshold_occ_det,
                               &#39;thr_occ_det_integral_fraction&#39;: thr_occ_det_integral_fraction,
                               &#39;tot_entries_b&#39;: tot_entries_b,
                               &#39;iterations&#39;: {&#39;threshold&#39;: thresholds_list,
                                              &#39;occupancy&#39;: occupancy_list,
                                              &#39;occupancy_err&#39;: occupancy_err_list,
                                              &#39;occupancy_smoothed&#39;: occupancy_list_smooth},
                               }

        return occupancy_estimator

    def get_gain_model_independent(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray,
                                   occupancy_estimator: dict) -&gt; dict:
        &#34;&#34;&#34;Calculate model independent gain value.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.
            occupancy_estimator: Output dictionary from `get_occupancy_model_independent` method.
                Must contain at least the following keys: `occupancy`, `occupancy_err`,
                `thr_occ_det_integral_fraction`, `tot_entries_b`.

        Returns:
            gain_estimator: Dictionary with the following keys:
                {&#39;moments_s&#39;: dict with first two moments of &#39;LED on&#39; area distribution,
                &#39;moments_b&#39;: dict with first two moments of &#39;LED off&#39; area distribution,
                &#39;mean_psi&#39;: mean of the single photoelectron response (unconverted gain),
                &#39;var_psi&#39;: variance of the single photoelectron response,
                &#39;mean_psi_stat_err&#39;: statistical error of mean_psi,
                &#39;mean_psi_sys_err&#39;: systematic error of mean_psi,
                &#39;mean_psi_err&#39;: total error of mean_psi}
        &#34;&#34;&#34;
        # Get moments of area distributions
        moments_s = self.get_moments(areas_led_on)
        mean_s = moments_s[&#39;mean&#39;]
        var_s = moments_s[&#39;variance&#39;]
        moments_b = self.get_moments(areas_led_off)
        mean_b = moments_b[&#39;mean&#39;]
        var_b = moments_b[&#39;variance&#39;]

        # Get occupancy related values
        occupancy = occupancy_estimator[&#39;occupancy&#39;]
        occupancy_err = occupancy_estimator[&#39;occupancy_err&#39;]
        f_b = occupancy_estimator[&#39;thr_occ_det_integral_fraction&#39;]
        tot_b = occupancy_estimator[&#39;tot_entries_b&#39;]

        # Calculate first two central moments of the single photoelectron response
        # and the uncertainties of the mean
        mean_psi = (mean_s - mean_b) / occupancy
        var_psi = (var_s - var_b) / occupancy - mean_psi**2
        mean_psi_stat_err = (occupancy * (mean_psi**2 + var_psi) + 2 * var_b) / (tot_b * occupancy**2) + (
                mean_psi * mean_psi * (np.exp(occupancy) + 1 - 2 * f_b)) / (f_b * tot_b * occupancy**2)
        mean_psi_sys_err = (mean_s - mean_b) * occupancy_err / (occupancy**2)
        mean_psi_err = np.sqrt(mean_psi_stat_err**2 + mean_psi_sys_err**2)

        gain_estimator = {&#39;moments_s&#39;: moments_s, &#39;moments_b&#39;: moments_b,
                          &#39;mean_psi&#39;: mean_psi, &#39;variance_psi&#39;: var_psi,
                          &#39;mean_psi_stat_err&#39;: mean_psi_stat_err, &#39;mean_psi_sys_err&#39;: mean_psi_sys_err,
                          &#39;mean_psi_err&#39;: mean_psi_err}

        return gain_estimator

    def compute(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray, adc_to_e: float = np.nan) -&gt; dict:
        &#34;&#34;&#34;Perform full model independent gain and occupancy calculation.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.
            adc_to_e: Conversion factor pulse area in ADC units to charge in units of elementary charge.

        Returns:
            output_dict: Dictionary with the following keys:
                {&#39;occupancy&#39;: final occupancy estimate;
                &#39;occupancy_err&#39;: uncertainty final occupancy estimate;
                &#39;threshold_occupancy_determination&#39;: threshold in 0PE peak area calculations
                    for final occupancy estimate;
                &#39;thr_occ_det_integral_fraction&#39;: fraction of entries in &#39;LED off&#39; data below threshold;
                &#39;tot_entries_b&#39;: total number of waveforms in &#39;LED off&#39; data,
                &#39;iterations&#39;: dictionary with the tested thresholds and corresponding
                    occupancy, occupancy uncertainty, and smoothed occupancy values,
                &#39;moments_s&#39;: dict with first two moments of &#39;LED on&#39; area distribution,
                &#39;moments_b&#39;: dict with first two moments of &#39;LED off&#39; area distribution,
                &#39;mean_psi&#39;: mean of the single photoelectron response (unconverted gain),
                &#39;var_psi&#39;: variance of the single photoelectron response,
                &#39;mean_psi_stat_err&#39;: statistical error of mean_psi,
                &#39;mean_psi_sys_err&#39;: systematic error of mean_psi,
                &#39;mean_psi_err&#39;: total error of mean_psi,
                &#39;gain&#39;: gain values (in units of read out electrons per induced photoelectron),
                &#39;gain_stat_err&#39;: statistical error gain,
                &#39;gain_sys_err&#39;: systematic error gain,
                &#39;gain_err&#39;: total error gain,
                &#39;outlier_thresholds&#39;: range of area values to be used (excluding outliers),
                &#39;histograms:&#39; dictionary with the bin centers and counts for &#39;LED on&#39; and &#39;LED off&#39;
                    area histograms with default bin width of 10
                }
        &#34;&#34;&#34;
        # Calculate occupancy and gain
        occupancy_estimator = self.get_occupancy_model_independent(areas_led_on, areas_led_off)
        gain_estimator = self.get_gain_model_independent(areas_led_on, areas_led_off, occupancy_estimator)

        # Convert to gain values (in units of read out electrons per induced photoelectron)
        if np.isnan(adc_to_e):
            warnings.warn(&#39;Unable to convert gain values as no valid input for adc_to_e provided.&#39;)
        gain_converted = gain_estimator[&#39;mean_psi&#39;] * adc_to_e
        gain_stat_err_converted = gain_estimator[&#39;mean_psi_stat_err&#39;] * adc_to_e
        gain_sys_err_converted = gain_estimator[&#39;mean_psi_sys_err&#39;] * adc_to_e
        gain_err_converted = gain_estimator[&#39;mean_psi_err&#39;] * adc_to_e
        if self.verbose:
            print(&#39;Estimated gain [10^6]: {:.3f} ± {:.3f} (stat) ± {:.3f} (syst)&#39;.format(
                gain_converted*1e-6, gain_stat_err_converted*1e-6, gain_sys_err_converted*1e-6))

        gain_estimator_converted = {&#39;gain&#39;: gain_converted, &#39;gain_stat_err&#39;: gain_stat_err_converted,
                                    &#39;gain_sys_err&#39;: gain_sys_err_converted, &#39;gain_err&#39;: gain_err_converted}

        # Generate histograms for later reference
        hist_bin_centers, hist_counts_led_on = self.get_area_histogram(areas_led_on, bin_width=10,
                                                                       limits=self.outliers_thresholds)
        hist_bin_centers, hist_counts_led_off = self.get_area_histogram(areas_led_off, bin_width=10,
                                                                        limits=self.outliers_thresholds)
        histograms = {&#39;histograms&#39;: {&#39;bin_centers&#39;: hist_bin_centers,
                                     &#39;counts_led_on&#39;: hist_counts_led_on,
                                     &#39;counts_led_off&#39;: hist_counts_led_off}}

        # Save everything in a dictionary
        output_dict = dict(**occupancy_estimator, **gain_estimator, **gain_estimator_converted,
                           **{&#39;outlier_thresholds&#39;: self.outliers_thresholds}, **histograms)
        return output_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent"><code class="flex name class">
<span>class <span class="ident">GainModelIndependent</span></span>
<span>(</span><span>areas_led_on: numpy.ndarray, areas_led_off: numpy.ndarray, verbose: bool = False, trim_outliers_bool: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for model independent occupancy and gain calculation.</p>
<p>Calculation of the gain, i.e. the current amplification factor of the PMT, following the statistical
method proposed in <code>Saldanha, R., et al. 'Model independent approach to the single photoelectron
calibration of photomultiplier tubes.' Nuclear Instruments and Methods in Physics Research Section A:
Accelerators, Spectrometers, Detectors and Associated Equipment 863 (2017): 35-46</code>.</p>
<p>Uses the peak area spectrum from pulsed low-intensity LED light illumination and LED triggered
data taking. The fixed window analysis takes two data sets, one with LED 'off'
(practically pulsed at low enough voltage amplitude to ensure no light emission from the LED)
and one with LED 'on', usually at a target occupancy (i.e. mean number photo electrons released
per LED trigger) of ca. 2 for uncertainty minimization.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>areas_led_on</code></strong></dt>
<dd>Array with 'LED on' data pulse areas.</dd>
<dt><strong><code>areas_led_off</code></strong></dt>
<dd>Array with 'LED off' data pulse areas.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>Verbosity of the output.</dd>
<dt><strong><code>outliers_thresholds</code></strong></dt>
<dd>Range of area values used for the time dependent gain calculation.</dd>
</dl>
<p>Init of the GainModelIndependent class.</p>
<p>Cleans and prepares the pulse area data inputs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>areas_led_on</code></strong></dt>
<dd>Array with 'LED on' data pulse areas.</dd>
<dt><strong><code>areas_led_off</code></strong></dt>
<dd>Array with 'LED off' data pulse areas.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>Verbosity of the output.</dd>
<dt><strong><code>trim_outliers_bool</code></strong></dt>
<dd>Remove outliers from input data using the <code>get_outlier_bounds</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GainModelIndependent:
    &#34;&#34;&#34;Class for model independent occupancy and gain calculation.

    Calculation of the gain, i.e. the current amplification factor of the PMT, following the statistical
    method proposed in `Saldanha, R., et al. &#39;Model independent approach to the single photoelectron
    calibration of photomultiplier tubes.&#39; Nuclear Instruments and Methods in Physics Research Section A:
    Accelerators, Spectrometers, Detectors and Associated Equipment 863 (2017): 35-46`.

    Uses the peak area spectrum from pulsed low-intensity LED light illumination and LED triggered
    data taking. The fixed window analysis takes two data sets, one with LED &#39;off&#39;
    (practically pulsed at low enough voltage amplitude to ensure no light emission from the LED)
    and one with LED &#39;on&#39;, usually at a target occupancy (i.e. mean number photo electrons released
    per LED trigger) of ca. 2 for uncertainty minimization.

    Attributes:
        areas_led_on: Array with &#39;LED on&#39; data pulse areas.
        areas_led_off: Array with &#39;LED off&#39; data pulse areas.
        verbose: Verbosity of the output.
        outliers_thresholds: Range of area values used for the time dependent gain calculation.
    &#34;&#34;&#34;

    def __init__(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray, verbose: bool = False,
                 trim_outliers_bool: bool = True):
        &#34;&#34;&#34;Init of the GainModelIndependent class.

        Cleans and prepares the pulse area data inputs.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.
            verbose: Verbosity of the output.
            trim_outliers_bool: Remove outliers from input data using the `get_outlier_bounds` method.
        &#34;&#34;&#34;
        self.verbose = verbose
        # Bring pulse area data inputs to numpy.ndarray format
        self.areas_led_on = self.inputs_to_numpy(areas_led_on)
        self.areas_led_off = self.inputs_to_numpy(areas_led_off)
        # Remove outlier values
        self.outliers_thresholds = (None, None)
        if trim_outliers_bool:
            if verbose:
                print(&#39;Calculating range of area values to be used for the time dependent gain calculation.&#39;)
            outlier_bound_lower, outlier_bound_upper = self.get_outlier_bounds(self.areas_led_on, self.verbose)
            self.outliers_thresholds = (outlier_bound_lower, outlier_bound_upper)
            if verbose:
                print(&#39;Trimming area outliers with limits [{}, {}].&#39;.format(outlier_bound_lower, outlier_bound_upper))
            self.areas_led_off = self.areas_led_off[(self.areas_led_off &gt;= outlier_bound_lower)
                                                    &amp; (self.areas_led_off &lt;= outlier_bound_upper)]
            self.areas_led_on = self.areas_led_on[(self.areas_led_on &gt;= outlier_bound_lower)
                                                  &amp; (self.areas_led_on &lt;= outlier_bound_upper)]

    @staticmethod
    def inputs_to_numpy(input_data: Union[np.ndarray, list, dict, pd.DataFrame, pd.Series]) -&gt; np.ndarray:
        &#34;&#34;&#34;Bring pulse area data inputs to numpy.ndarray format.

        Args:
            input_data: Input pulse area data.
                Allowed types: `numpy.ndarray, list, dict, pandas.DataFrame, pandas.Series`
        Returns:
            input_data: Input data converted to numpy.ndarray.
        &#34;&#34;&#34;
        if type(input_data) == np.ndarray:
            pass
        elif type(input_data) == list:
            input_data = np.asarray(input_data)
        elif type(input_data) == dict:
            if &#39;area&#39; not in input_data.keys():
                raise KeyError(&#39;No key name `area` found in provided dictionary `input_data`.&#39;)
            elif type(input_data[&#39;area&#39;]) == np.ndarray:
                input_data = input_data[&#39;area&#39;]
            elif type(input_data[&#39;area&#39;]) == list:
                input_data = np.asarray(input_data[&#39;area&#39;])
            else:
                raise TypeError(&#39;Unsupported type for `input_data`.&#39;)
        elif type(input_data) == pd.DataFrame:
            if &#39;area&#39; not in input_data.columns:
                raise KeyError(&#39;No column name `area` found in provided data frame `input_data`.&#39;)
            else:
                input_data = input_data[&#39;area&#39;].to_numpy()
        elif type(input_data) == pd.Series:
            input_data = input_data.to_numpy()
        else:
            raise TypeError(&#39;Unsupported type for `input_data`.&#39;)
        return input_data

    @staticmethod
    def get_outlier_bounds(input_data: np.ndarray, verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;Calculate boundaries for outlier rejection.

        Outliers may bias the model independent gain calculation due to their large lever and
        should hence be removed.
        Determined are the values at which the entries in a window of size based on square-root
        binning falls below a certain threshold.

        Args:
            input_data: Input pulse area data.
            verbose: Verbosity of the output.

        Returns:
            Tuple with upper and lower bound to be used for outlier rejection.
        &#34;&#34;&#34;
        window_width = np.ceil((np.percentile(input_data, 99.99) - np.percentile(input_data, 0.01))
                               / np.sqrt(input_data.shape[0]))
        window_width = 5*window_width
        window_counts_threshold = 1
        for i in tqdm(count(0), disable=not bool(verbose)):
            if len(input_data[(input_data &gt;= i) &amp; (input_data &lt; i + window_width)]) &lt;= window_counts_threshold:
                break
        outlier_bound_upper = i + window_width
        for i in tqdm(count(0), disable=not bool(verbose)):
            if len(input_data[(input_data &lt;= -i) &amp; (input_data &gt; -(i + window_width))]) &lt;= window_counts_threshold:
                break
        outlier_bound_lower = -(i + window_width)
        return outlier_bound_lower, outlier_bound_upper

    @staticmethod
    def get_area_histogram(input_data: np.ndarray, bin_width: int = 1,
                           limits: Optional[Tuple[int, int]] = None) -&gt; tuple:
        &#34;&#34;&#34;Function to generate area histogram with given bin width.

        Args:
            input_data: Input pulse area data.
            bin_width: Bin width.
            limits: Range of histogram bins.

        Returns:
            tuple(bins_centers, cnts): Tuple with bins centers and corresponding counts values.
        &#34;&#34;&#34;
        try:
            bin_width = int(bin_width)
        except Exception:
            raise TypeError(&#39;bin_width must be of type int.&#39;)
        if limits is not None:
            if len(limits) != 2:
                raise ValueError(&#39;Limits must be a tuple of length 2.&#39;)
            try:
                limits_lower = int(limits[0])
                limits_upper = int(limits[1])
            except Exception:
                raise TypeError(&#39;Entries of limits must be of type int.&#39;)
            bins_edges = np.arange(limits_lower - 0.5, limits_upper + 1.5, bin_width)
        else:
            bins_edges = np.arange(np.min(input_data) - 0.5, np.max(input_data) + 1.5, bin_width)
        bins_centers = (bins_edges[1:] + bins_edges[:-1]) / 2
        counts, _ = np.histogram(input_data, bins=bins_edges)
        return bins_centers, counts

    @staticmethod
    def get_moments(input_data: np.ndarray) -&gt; dict:
        &#34;&#34;&#34;Calculate moments relevant for model independent gains calculation.

        Args:
            input_data: Input pulse area data.

        Returns:
            Dictionary with moments relevant for model independent gains calculation.
        &#34;&#34;&#34;
        dict_moments = dict()
        dict_moments[&#39;mean&#39;] = np.mean(input_data)
        dict_moments[&#39;variance&#39;] = np.var(input_data)
        return dict_moments

    @staticmethod
    def sav_gol_smoothing(input_data: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Smooth `input_data` with Savitzky–Golay filter.

        Args:
            input_data: Input threshold dependent occupancy values.

        Returns:
            output_data: Savitzky–Golay filter smoothed input data.
        &#34;&#34;&#34;
        # Set length of the filter window
        num = len(input_data) - 1
        if num % 2 == 0:
            num = num - 1
        # Set order of the polynomial used to fit the samples
        order = 10
        order = min(order, num - 1)
        # Apply filter
        output_data = savgol_filter(input_data, num, order)
        return output_data

    def get_occupancy_model_independent(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray) -&gt; dict:
        &#34;&#34;&#34;Calculate the occupancy for the model independent gain calculation.

        For a range of thresholds within the 0PE peak areas, calculate the number of entries
        below threshold for &#39;LED off&#39; (`integral_b`) and &#39;LED on&#39; (`integral_s`) data areas.
        The occupancy can be estimated from the number of &#39;LED on&#39; sample triggers with
        zero LED-induced photoelectrons, as can be assumed for a sufficiently low threshold
        for `integral_s`, and the total number of sample triggers, as can be by proportion estimated
        through `integral_b`. As the number of photoelectrons produced follows a Poisson distribution,
        we can use the expression `-ln(integral_s/integral_b)` as an estimator for the occupancy for the
        selected threshold. This threshold is supposed to be sufficiently low such that `integral_s` is
        not contaminated by a significant 1PE contribution. We therefore try to find the lowest
        threshold for which sufficient data points are available below threshold to achieve a
        relative occupancy error of below 1%. Ideally this is located in a local and global
        maximum plateau around / slightly below zero areas.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.

        Returns:
            occupancy_estimator: Dictionary with the following keys:
                {&#39;occupancy&#39;: final occupancy estimate;
                &#39;occupancy_err&#39;: uncertainty final occupancy estimate;
                &#39;threshold_occupancy_determination&#39;: threshold in 0PE peak area calculations
                    for final occupancy estimate;
                &#39;thr_occ_det_integral_fraction&#39;: fraction of entries in &#39;LED off&#39; data below threshold;
                &#39;tot_entries_b&#39;: total number of waveforms in &#39;LED off&#39; data,
                &#39;iterations&#39;: dictionary with the tested thresholds and corresponding
                    occupancy, occupancy uncertainty, and smoothed occupancy values}
        &#34;&#34;&#34;
        # Total number of waveforms in &#39;LED off&#39; data
        tot_entries_b = areas_led_off.shape[0]

        # Define list of thresholds to probe in iterative occupancy determination
        if self.outliers_thresholds[0] is None:
            thr_it_occ_det = np.abs(self.get_outlier_bounds(areas_led_on)[0])
        else:
            thr_it_occ_det = np.abs(self.outliers_thresholds[0])
        lower_thr_it_occ_det = - thr_it_occ_det / 2
        upper_thr_it_occ_det = thr_it_occ_det / 2
        list_thr_it_occ_det = np.arange(lower_thr_it_occ_det, upper_thr_it_occ_det + 1)

        # Initialize lists for resulting occupancies as a function of threshold.
        # Use lists with append as it showed to be faster than np.arrays in this application.
        occupancy_list = list()
        occupancy_err_list = list()
        thresholds_list = list()
        f_list = list()

        # Loop over thresholds and calculate corresponding occupancy and error
        for threshold in list_thr_it_occ_det:
            # Calculate number of entries below peak area threshold for &#39;LED off&#39; (integral_b) and
            # &#39;LED on&#39; (integral_s) data. Correction factor on integral_b (and later also f) should
            # be close to one and only correct for differences due to outlier removal.
            # If significantly different cardinalities of LED on and off data sets are used,
            # the error calculation below may become incorrect.
            integral_b = np.sum(areas_led_off &lt; threshold) * len(areas_led_on) / len(areas_led_off)
            integral_s = np.sum(areas_led_on &lt; threshold)

            # Perform occupancy calculations only for positive number of entries below threshold
            if integral_b &gt; 0 and integral_s &gt; 0:
                # Fraction of entries in &#39;LED off&#39; data below threshold
                f = integral_b / (tot_entries_b * len(areas_led_on) / len(areas_led_off))
                # The occupancy can be estimated from the number of &#39;LED on&#39; sample triggers with zero LED-induced
                # photoelectrons, as can be assumed for a sufficiently low threshold for integral_s, and the
                # total number of sample triggers, as can be by proportion estimated through integral_b.
                # As the number of photoelectrons produced follows a Poisson distribution, we can use the following
                # expression as an estimator for the occupancy for the selected threshold (which, if sufficiently low
                # to not be contaminated by a significant 1PE contribution,
                # should not change the obtained occupancy value).
                l_val = -np.log(integral_s / integral_b)
                l_err = np.sqrt((np.exp(l_val) + 1. - 2. * f) / integral_b)

                # Only consider occupancy values with relative uncertainties below 5%.
                if l_err / l_val &lt;= 0.05:
                    occupancy_list.append(l_val)
                    occupancy_err_list.append(l_err)
                    thresholds_list.append(threshold)
                    f_list.append(f)

        if len(occupancy_list) == 0:
            raise ValueError(&#39;No occupancy values determined in threshold iterations.&#39;)

        # Convert to numpy arrays
        occupancy_list = np.asarray(occupancy_list)
        occupancy_err_list = np.asarray(occupancy_err_list)
        thresholds_list = np.asarray(thresholds_list)
        f_list = np.asarray(f_list)

        # Smooth threshold-dependent occupancies with Savitzky–Golay filter
        occupancy_list_smooth = self.sav_gol_smoothing(occupancy_list)

        # Sort indices in smoothed occupancy list by their element value in descending order
        occupancy_list_smooth_argsort = occupancy_list_smooth.argsort()[::-1]

        # Find threshold and corresponding occupancy for highest smoothed occupancy value
        # for which the relative occupancy error is below 1%.
        # Ideally this is located in a local and global maximum plateau around / slightly below zero areas
        # where 1PE contributions are negligible but on the other hand sufficient data points are available
        # below the threshold to bring the relative uncertainty down to the required level.
        # If no threshold value fulfils this criterion, return NaN occupancy.
        occupancy_estimate = np.nan
        occupancy_estimate_err = np.nan
        threshold_occ_det = np.nan
        thr_occ_det_integral_fraction = np.nan
        for idx in occupancy_list_smooth_argsort:
            if occupancy_err_list[idx] / occupancy_list[idx] &lt; 0.01:
                occupancy_estimate = occupancy_list[idx]
                occupancy_estimate_err = occupancy_err_list[idx]
                threshold_occ_det = thresholds_list[idx]
                thr_occ_det_integral_fraction = f_list[idx]
                break

        if np.isnan(occupancy_estimate):
            warnings.warn(&#39;Failed to estimate occupancy with the required precision. Returned NaN.&#39;)
        elif occupancy_estimate &lt;= 0:
            warnings.warn(&#39;Warning: Estimated occupancy ({:.3f} ± {:.3f}) seems to be &#39;
                          &#39;less than zero.&#39;.format(occupancy_estimate, occupancy_estimate_err))
        elif self.verbose:
            print(&#39;Threshold for occupancy estimation: {}&#39;.format(threshold_occ_det))
            print(&#39;Estimated occupancy: {:.3f} ± {:.3f}&#39;.format(occupancy_estimate, occupancy_estimate_err))

        occupancy_estimator = {&#39;occupancy&#39;: occupancy_estimate,
                               &#39;occupancy_err&#39;: occupancy_estimate_err,
                               &#39;threshold_occupancy_determination&#39;: threshold_occ_det,
                               &#39;thr_occ_det_integral_fraction&#39;: thr_occ_det_integral_fraction,
                               &#39;tot_entries_b&#39;: tot_entries_b,
                               &#39;iterations&#39;: {&#39;threshold&#39;: thresholds_list,
                                              &#39;occupancy&#39;: occupancy_list,
                                              &#39;occupancy_err&#39;: occupancy_err_list,
                                              &#39;occupancy_smoothed&#39;: occupancy_list_smooth},
                               }

        return occupancy_estimator

    def get_gain_model_independent(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray,
                                   occupancy_estimator: dict) -&gt; dict:
        &#34;&#34;&#34;Calculate model independent gain value.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.
            occupancy_estimator: Output dictionary from `get_occupancy_model_independent` method.
                Must contain at least the following keys: `occupancy`, `occupancy_err`,
                `thr_occ_det_integral_fraction`, `tot_entries_b`.

        Returns:
            gain_estimator: Dictionary with the following keys:
                {&#39;moments_s&#39;: dict with first two moments of &#39;LED on&#39; area distribution,
                &#39;moments_b&#39;: dict with first two moments of &#39;LED off&#39; area distribution,
                &#39;mean_psi&#39;: mean of the single photoelectron response (unconverted gain),
                &#39;var_psi&#39;: variance of the single photoelectron response,
                &#39;mean_psi_stat_err&#39;: statistical error of mean_psi,
                &#39;mean_psi_sys_err&#39;: systematic error of mean_psi,
                &#39;mean_psi_err&#39;: total error of mean_psi}
        &#34;&#34;&#34;
        # Get moments of area distributions
        moments_s = self.get_moments(areas_led_on)
        mean_s = moments_s[&#39;mean&#39;]
        var_s = moments_s[&#39;variance&#39;]
        moments_b = self.get_moments(areas_led_off)
        mean_b = moments_b[&#39;mean&#39;]
        var_b = moments_b[&#39;variance&#39;]

        # Get occupancy related values
        occupancy = occupancy_estimator[&#39;occupancy&#39;]
        occupancy_err = occupancy_estimator[&#39;occupancy_err&#39;]
        f_b = occupancy_estimator[&#39;thr_occ_det_integral_fraction&#39;]
        tot_b = occupancy_estimator[&#39;tot_entries_b&#39;]

        # Calculate first two central moments of the single photoelectron response
        # and the uncertainties of the mean
        mean_psi = (mean_s - mean_b) / occupancy
        var_psi = (var_s - var_b) / occupancy - mean_psi**2
        mean_psi_stat_err = (occupancy * (mean_psi**2 + var_psi) + 2 * var_b) / (tot_b * occupancy**2) + (
                mean_psi * mean_psi * (np.exp(occupancy) + 1 - 2 * f_b)) / (f_b * tot_b * occupancy**2)
        mean_psi_sys_err = (mean_s - mean_b) * occupancy_err / (occupancy**2)
        mean_psi_err = np.sqrt(mean_psi_stat_err**2 + mean_psi_sys_err**2)

        gain_estimator = {&#39;moments_s&#39;: moments_s, &#39;moments_b&#39;: moments_b,
                          &#39;mean_psi&#39;: mean_psi, &#39;variance_psi&#39;: var_psi,
                          &#39;mean_psi_stat_err&#39;: mean_psi_stat_err, &#39;mean_psi_sys_err&#39;: mean_psi_sys_err,
                          &#39;mean_psi_err&#39;: mean_psi_err}

        return gain_estimator

    def compute(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray, adc_to_e: float = np.nan) -&gt; dict:
        &#34;&#34;&#34;Perform full model independent gain and occupancy calculation.

        Args:
            areas_led_on: Array with &#39;LED on&#39; data pulse areas.
            areas_led_off: Array with &#39;LED off&#39; data pulse areas.
            adc_to_e: Conversion factor pulse area in ADC units to charge in units of elementary charge.

        Returns:
            output_dict: Dictionary with the following keys:
                {&#39;occupancy&#39;: final occupancy estimate;
                &#39;occupancy_err&#39;: uncertainty final occupancy estimate;
                &#39;threshold_occupancy_determination&#39;: threshold in 0PE peak area calculations
                    for final occupancy estimate;
                &#39;thr_occ_det_integral_fraction&#39;: fraction of entries in &#39;LED off&#39; data below threshold;
                &#39;tot_entries_b&#39;: total number of waveforms in &#39;LED off&#39; data,
                &#39;iterations&#39;: dictionary with the tested thresholds and corresponding
                    occupancy, occupancy uncertainty, and smoothed occupancy values,
                &#39;moments_s&#39;: dict with first two moments of &#39;LED on&#39; area distribution,
                &#39;moments_b&#39;: dict with first two moments of &#39;LED off&#39; area distribution,
                &#39;mean_psi&#39;: mean of the single photoelectron response (unconverted gain),
                &#39;var_psi&#39;: variance of the single photoelectron response,
                &#39;mean_psi_stat_err&#39;: statistical error of mean_psi,
                &#39;mean_psi_sys_err&#39;: systematic error of mean_psi,
                &#39;mean_psi_err&#39;: total error of mean_psi,
                &#39;gain&#39;: gain values (in units of read out electrons per induced photoelectron),
                &#39;gain_stat_err&#39;: statistical error gain,
                &#39;gain_sys_err&#39;: systematic error gain,
                &#39;gain_err&#39;: total error gain,
                &#39;outlier_thresholds&#39;: range of area values to be used (excluding outliers),
                &#39;histograms:&#39; dictionary with the bin centers and counts for &#39;LED on&#39; and &#39;LED off&#39;
                    area histograms with default bin width of 10
                }
        &#34;&#34;&#34;
        # Calculate occupancy and gain
        occupancy_estimator = self.get_occupancy_model_independent(areas_led_on, areas_led_off)
        gain_estimator = self.get_gain_model_independent(areas_led_on, areas_led_off, occupancy_estimator)

        # Convert to gain values (in units of read out electrons per induced photoelectron)
        if np.isnan(adc_to_e):
            warnings.warn(&#39;Unable to convert gain values as no valid input for adc_to_e provided.&#39;)
        gain_converted = gain_estimator[&#39;mean_psi&#39;] * adc_to_e
        gain_stat_err_converted = gain_estimator[&#39;mean_psi_stat_err&#39;] * adc_to_e
        gain_sys_err_converted = gain_estimator[&#39;mean_psi_sys_err&#39;] * adc_to_e
        gain_err_converted = gain_estimator[&#39;mean_psi_err&#39;] * adc_to_e
        if self.verbose:
            print(&#39;Estimated gain [10^6]: {:.3f} ± {:.3f} (stat) ± {:.3f} (syst)&#39;.format(
                gain_converted*1e-6, gain_stat_err_converted*1e-6, gain_sys_err_converted*1e-6))

        gain_estimator_converted = {&#39;gain&#39;: gain_converted, &#39;gain_stat_err&#39;: gain_stat_err_converted,
                                    &#39;gain_sys_err&#39;: gain_sys_err_converted, &#39;gain_err&#39;: gain_err_converted}

        # Generate histograms for later reference
        hist_bin_centers, hist_counts_led_on = self.get_area_histogram(areas_led_on, bin_width=10,
                                                                       limits=self.outliers_thresholds)
        hist_bin_centers, hist_counts_led_off = self.get_area_histogram(areas_led_off, bin_width=10,
                                                                        limits=self.outliers_thresholds)
        histograms = {&#39;histograms&#39;: {&#39;bin_centers&#39;: hist_bin_centers,
                                     &#39;counts_led_on&#39;: hist_counts_led_on,
                                     &#39;counts_led_off&#39;: hist_counts_led_off}}

        # Save everything in a dictionary
        output_dict = dict(**occupancy_estimator, **gain_estimator, **gain_estimator_converted,
                           **{&#39;outlier_thresholds&#39;: self.outliers_thresholds}, **histograms)
        return output_dict</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.get_area_histogram"><code class="name flex">
<span>def <span class="ident">get_area_histogram</span></span>(<span>input_data: numpy.ndarray, bin_width: int = 1, limits: Optional[Tuple[int, int]] = None) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Function to generate area histogram with given bin width.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_data</code></strong></dt>
<dd>Input pulse area data.</dd>
<dt><strong><code>bin_width</code></strong></dt>
<dd>Bin width.</dd>
<dt><strong><code>limits</code></strong></dt>
<dd>Range of histogram bins.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple(bins_centers, cnts): Tuple with bins centers and corresponding counts values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_area_histogram(input_data: np.ndarray, bin_width: int = 1,
                       limits: Optional[Tuple[int, int]] = None) -&gt; tuple:
    &#34;&#34;&#34;Function to generate area histogram with given bin width.

    Args:
        input_data: Input pulse area data.
        bin_width: Bin width.
        limits: Range of histogram bins.

    Returns:
        tuple(bins_centers, cnts): Tuple with bins centers and corresponding counts values.
    &#34;&#34;&#34;
    try:
        bin_width = int(bin_width)
    except Exception:
        raise TypeError(&#39;bin_width must be of type int.&#39;)
    if limits is not None:
        if len(limits) != 2:
            raise ValueError(&#39;Limits must be a tuple of length 2.&#39;)
        try:
            limits_lower = int(limits[0])
            limits_upper = int(limits[1])
        except Exception:
            raise TypeError(&#39;Entries of limits must be of type int.&#39;)
        bins_edges = np.arange(limits_lower - 0.5, limits_upper + 1.5, bin_width)
    else:
        bins_edges = np.arange(np.min(input_data) - 0.5, np.max(input_data) + 1.5, bin_width)
    bins_centers = (bins_edges[1:] + bins_edges[:-1]) / 2
    counts, _ = np.histogram(input_data, bins=bins_edges)
    return bins_centers, counts</code></pre>
</details>
</dd>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.get_moments"><code class="name flex">
<span>def <span class="ident">get_moments</span></span>(<span>input_data: numpy.ndarray) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moments relevant for model independent gains calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_data</code></strong></dt>
<dd>Input pulse area data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with moments relevant for model independent gains calculation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_moments(input_data: np.ndarray) -&gt; dict:
    &#34;&#34;&#34;Calculate moments relevant for model independent gains calculation.

    Args:
        input_data: Input pulse area data.

    Returns:
        Dictionary with moments relevant for model independent gains calculation.
    &#34;&#34;&#34;
    dict_moments = dict()
    dict_moments[&#39;mean&#39;] = np.mean(input_data)
    dict_moments[&#39;variance&#39;] = np.var(input_data)
    return dict_moments</code></pre>
</details>
</dd>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.get_outlier_bounds"><code class="name flex">
<span>def <span class="ident">get_outlier_bounds</span></span>(<span>input_data: numpy.ndarray, verbose: bool = False) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate boundaries for outlier rejection.</p>
<p>Outliers may bias the model independent gain calculation due to their large lever and
should hence be removed.
Determined are the values at which the entries in a window of size based on square-root
binning falls below a certain threshold.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_data</code></strong></dt>
<dd>Input pulse area data.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>Verbosity of the output.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple with upper and lower bound to be used for outlier rejection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_outlier_bounds(input_data: np.ndarray, verbose: bool = False) -&gt; tuple:
    &#34;&#34;&#34;Calculate boundaries for outlier rejection.

    Outliers may bias the model independent gain calculation due to their large lever and
    should hence be removed.
    Determined are the values at which the entries in a window of size based on square-root
    binning falls below a certain threshold.

    Args:
        input_data: Input pulse area data.
        verbose: Verbosity of the output.

    Returns:
        Tuple with upper and lower bound to be used for outlier rejection.
    &#34;&#34;&#34;
    window_width = np.ceil((np.percentile(input_data, 99.99) - np.percentile(input_data, 0.01))
                           / np.sqrt(input_data.shape[0]))
    window_width = 5*window_width
    window_counts_threshold = 1
    for i in tqdm(count(0), disable=not bool(verbose)):
        if len(input_data[(input_data &gt;= i) &amp; (input_data &lt; i + window_width)]) &lt;= window_counts_threshold:
            break
    outlier_bound_upper = i + window_width
    for i in tqdm(count(0), disable=not bool(verbose)):
        if len(input_data[(input_data &lt;= -i) &amp; (input_data &gt; -(i + window_width))]) &lt;= window_counts_threshold:
            break
    outlier_bound_lower = -(i + window_width)
    return outlier_bound_lower, outlier_bound_upper</code></pre>
</details>
</dd>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.inputs_to_numpy"><code class="name flex">
<span>def <span class="ident">inputs_to_numpy</span></span>(<span>input_data: Union[numpy.ndarray, list, dict, pandas.core.frame.DataFrame, pandas.core.series.Series]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Bring pulse area data inputs to numpy.ndarray format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_data</code></strong></dt>
<dd>Input pulse area data.
Allowed types: <code>numpy.ndarray, list, dict, pandas.DataFrame, pandas.Series</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>input_data</code></dt>
<dd>Input data converted to numpy.ndarray.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def inputs_to_numpy(input_data: Union[np.ndarray, list, dict, pd.DataFrame, pd.Series]) -&gt; np.ndarray:
    &#34;&#34;&#34;Bring pulse area data inputs to numpy.ndarray format.

    Args:
        input_data: Input pulse area data.
            Allowed types: `numpy.ndarray, list, dict, pandas.DataFrame, pandas.Series`
    Returns:
        input_data: Input data converted to numpy.ndarray.
    &#34;&#34;&#34;
    if type(input_data) == np.ndarray:
        pass
    elif type(input_data) == list:
        input_data = np.asarray(input_data)
    elif type(input_data) == dict:
        if &#39;area&#39; not in input_data.keys():
            raise KeyError(&#39;No key name `area` found in provided dictionary `input_data`.&#39;)
        elif type(input_data[&#39;area&#39;]) == np.ndarray:
            input_data = input_data[&#39;area&#39;]
        elif type(input_data[&#39;area&#39;]) == list:
            input_data = np.asarray(input_data[&#39;area&#39;])
        else:
            raise TypeError(&#39;Unsupported type for `input_data`.&#39;)
    elif type(input_data) == pd.DataFrame:
        if &#39;area&#39; not in input_data.columns:
            raise KeyError(&#39;No column name `area` found in provided data frame `input_data`.&#39;)
        else:
            input_data = input_data[&#39;area&#39;].to_numpy()
    elif type(input_data) == pd.Series:
        input_data = input_data.to_numpy()
    else:
        raise TypeError(&#39;Unsupported type for `input_data`.&#39;)
    return input_data</code></pre>
</details>
</dd>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.sav_gol_smoothing"><code class="name flex">
<span>def <span class="ident">sav_gol_smoothing</span></span>(<span>input_data: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Smooth <code>input_data</code> with Savitzky–Golay filter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_data</code></strong></dt>
<dd>Input threshold dependent occupancy values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>output_data</code></dt>
<dd>Savitzky–Golay filter smoothed input data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sav_gol_smoothing(input_data: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Smooth `input_data` with Savitzky–Golay filter.

    Args:
        input_data: Input threshold dependent occupancy values.

    Returns:
        output_data: Savitzky–Golay filter smoothed input data.
    &#34;&#34;&#34;
    # Set length of the filter window
    num = len(input_data) - 1
    if num % 2 == 0:
        num = num - 1
    # Set order of the polynomial used to fit the samples
    order = 10
    order = min(order, num - 1)
    # Apply filter
    output_data = savgol_filter(input_data, num, order)
    return output_data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.compute"><code class="name flex">
<span>def <span class="ident">compute</span></span>(<span>self, areas_led_on: numpy.ndarray, areas_led_off: numpy.ndarray, adc_to_e: float = nan) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Perform full model independent gain and occupancy calculation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>areas_led_on</code></strong></dt>
<dd>Array with 'LED on' data pulse areas.</dd>
<dt><strong><code>areas_led_off</code></strong></dt>
<dd>Array with 'LED off' data pulse areas.</dd>
<dt><strong><code>adc_to_e</code></strong></dt>
<dd>Conversion factor pulse area in ADC units to charge in units of elementary charge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>output_dict</code></dt>
<dd>Dictionary with the following keys:
{'occupancy': final occupancy estimate;
'occupancy_err': uncertainty final occupancy estimate;
'threshold_occupancy_determination': threshold in 0PE peak area calculations
for final occupancy estimate;
'thr_occ_det_integral_fraction': fraction of entries in 'LED off' data below threshold;
'tot_entries_b': total number of waveforms in 'LED off' data,
'iterations': dictionary with the tested thresholds and corresponding
occupancy, occupancy uncertainty, and smoothed occupancy values,
'moments_s': dict with first two moments of 'LED on' area distribution,
'moments_b': dict with first two moments of 'LED off' area distribution,
'mean_psi': mean of the single photoelectron response (unconverted gain),
'var_psi': variance of the single photoelectron response,
'mean_psi_stat_err': statistical error of mean_psi,
'mean_psi_sys_err': systematic error of mean_psi,
'mean_psi_err': total error of mean_psi,
'gain': gain values (in units of read out electrons per induced photoelectron),
'gain_stat_err': statistical error gain,
'gain_sys_err': systematic error gain,
'gain_err': total error gain,
'outlier_thresholds': range of area values to be used (excluding outliers),
'histograms:' dictionary with the bin centers and counts for 'LED on' and 'LED off'
area histograms with default bin width of 10
}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray, adc_to_e: float = np.nan) -&gt; dict:
    &#34;&#34;&#34;Perform full model independent gain and occupancy calculation.

    Args:
        areas_led_on: Array with &#39;LED on&#39; data pulse areas.
        areas_led_off: Array with &#39;LED off&#39; data pulse areas.
        adc_to_e: Conversion factor pulse area in ADC units to charge in units of elementary charge.

    Returns:
        output_dict: Dictionary with the following keys:
            {&#39;occupancy&#39;: final occupancy estimate;
            &#39;occupancy_err&#39;: uncertainty final occupancy estimate;
            &#39;threshold_occupancy_determination&#39;: threshold in 0PE peak area calculations
                for final occupancy estimate;
            &#39;thr_occ_det_integral_fraction&#39;: fraction of entries in &#39;LED off&#39; data below threshold;
            &#39;tot_entries_b&#39;: total number of waveforms in &#39;LED off&#39; data,
            &#39;iterations&#39;: dictionary with the tested thresholds and corresponding
                occupancy, occupancy uncertainty, and smoothed occupancy values,
            &#39;moments_s&#39;: dict with first two moments of &#39;LED on&#39; area distribution,
            &#39;moments_b&#39;: dict with first two moments of &#39;LED off&#39; area distribution,
            &#39;mean_psi&#39;: mean of the single photoelectron response (unconverted gain),
            &#39;var_psi&#39;: variance of the single photoelectron response,
            &#39;mean_psi_stat_err&#39;: statistical error of mean_psi,
            &#39;mean_psi_sys_err&#39;: systematic error of mean_psi,
            &#39;mean_psi_err&#39;: total error of mean_psi,
            &#39;gain&#39;: gain values (in units of read out electrons per induced photoelectron),
            &#39;gain_stat_err&#39;: statistical error gain,
            &#39;gain_sys_err&#39;: systematic error gain,
            &#39;gain_err&#39;: total error gain,
            &#39;outlier_thresholds&#39;: range of area values to be used (excluding outliers),
            &#39;histograms:&#39; dictionary with the bin centers and counts for &#39;LED on&#39; and &#39;LED off&#39;
                area histograms with default bin width of 10
            }
    &#34;&#34;&#34;
    # Calculate occupancy and gain
    occupancy_estimator = self.get_occupancy_model_independent(areas_led_on, areas_led_off)
    gain_estimator = self.get_gain_model_independent(areas_led_on, areas_led_off, occupancy_estimator)

    # Convert to gain values (in units of read out electrons per induced photoelectron)
    if np.isnan(adc_to_e):
        warnings.warn(&#39;Unable to convert gain values as no valid input for adc_to_e provided.&#39;)
    gain_converted = gain_estimator[&#39;mean_psi&#39;] * adc_to_e
    gain_stat_err_converted = gain_estimator[&#39;mean_psi_stat_err&#39;] * adc_to_e
    gain_sys_err_converted = gain_estimator[&#39;mean_psi_sys_err&#39;] * adc_to_e
    gain_err_converted = gain_estimator[&#39;mean_psi_err&#39;] * adc_to_e
    if self.verbose:
        print(&#39;Estimated gain [10^6]: {:.3f} ± {:.3f} (stat) ± {:.3f} (syst)&#39;.format(
            gain_converted*1e-6, gain_stat_err_converted*1e-6, gain_sys_err_converted*1e-6))

    gain_estimator_converted = {&#39;gain&#39;: gain_converted, &#39;gain_stat_err&#39;: gain_stat_err_converted,
                                &#39;gain_sys_err&#39;: gain_sys_err_converted, &#39;gain_err&#39;: gain_err_converted}

    # Generate histograms for later reference
    hist_bin_centers, hist_counts_led_on = self.get_area_histogram(areas_led_on, bin_width=10,
                                                                   limits=self.outliers_thresholds)
    hist_bin_centers, hist_counts_led_off = self.get_area_histogram(areas_led_off, bin_width=10,
                                                                    limits=self.outliers_thresholds)
    histograms = {&#39;histograms&#39;: {&#39;bin_centers&#39;: hist_bin_centers,
                                 &#39;counts_led_on&#39;: hist_counts_led_on,
                                 &#39;counts_led_off&#39;: hist_counts_led_off}}

    # Save everything in a dictionary
    output_dict = dict(**occupancy_estimator, **gain_estimator, **gain_estimator_converted,
                       **{&#39;outlier_thresholds&#39;: self.outliers_thresholds}, **histograms)
    return output_dict</code></pre>
</details>
</dd>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.get_gain_model_independent"><code class="name flex">
<span>def <span class="ident">get_gain_model_independent</span></span>(<span>self, areas_led_on: numpy.ndarray, areas_led_off: numpy.ndarray, occupancy_estimator: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate model independent gain value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>areas_led_on</code></strong></dt>
<dd>Array with 'LED on' data pulse areas.</dd>
<dt><strong><code>areas_led_off</code></strong></dt>
<dd>Array with 'LED off' data pulse areas.</dd>
<dt><strong><code>occupancy_estimator</code></strong></dt>
<dd>Output dictionary from <code>get_occupancy_model_independent</code> method.
Must contain at least the following keys: <code>occupancy</code>, <code>occupancy_err</code>,
<code>thr_occ_det_integral_fraction</code>, <code>tot_entries_b</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gain_estimator</code></dt>
<dd>Dictionary with the following keys:
{'moments_s': dict with first two moments of 'LED on' area distribution,
'moments_b': dict with first two moments of 'LED off' area distribution,
'mean_psi': mean of the single photoelectron response (unconverted gain),
'var_psi': variance of the single photoelectron response,
'mean_psi_stat_err': statistical error of mean_psi,
'mean_psi_sys_err': systematic error of mean_psi,
'mean_psi_err': total error of mean_psi}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gain_model_independent(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray,
                               occupancy_estimator: dict) -&gt; dict:
    &#34;&#34;&#34;Calculate model independent gain value.

    Args:
        areas_led_on: Array with &#39;LED on&#39; data pulse areas.
        areas_led_off: Array with &#39;LED off&#39; data pulse areas.
        occupancy_estimator: Output dictionary from `get_occupancy_model_independent` method.
            Must contain at least the following keys: `occupancy`, `occupancy_err`,
            `thr_occ_det_integral_fraction`, `tot_entries_b`.

    Returns:
        gain_estimator: Dictionary with the following keys:
            {&#39;moments_s&#39;: dict with first two moments of &#39;LED on&#39; area distribution,
            &#39;moments_b&#39;: dict with first two moments of &#39;LED off&#39; area distribution,
            &#39;mean_psi&#39;: mean of the single photoelectron response (unconverted gain),
            &#39;var_psi&#39;: variance of the single photoelectron response,
            &#39;mean_psi_stat_err&#39;: statistical error of mean_psi,
            &#39;mean_psi_sys_err&#39;: systematic error of mean_psi,
            &#39;mean_psi_err&#39;: total error of mean_psi}
    &#34;&#34;&#34;
    # Get moments of area distributions
    moments_s = self.get_moments(areas_led_on)
    mean_s = moments_s[&#39;mean&#39;]
    var_s = moments_s[&#39;variance&#39;]
    moments_b = self.get_moments(areas_led_off)
    mean_b = moments_b[&#39;mean&#39;]
    var_b = moments_b[&#39;variance&#39;]

    # Get occupancy related values
    occupancy = occupancy_estimator[&#39;occupancy&#39;]
    occupancy_err = occupancy_estimator[&#39;occupancy_err&#39;]
    f_b = occupancy_estimator[&#39;thr_occ_det_integral_fraction&#39;]
    tot_b = occupancy_estimator[&#39;tot_entries_b&#39;]

    # Calculate first two central moments of the single photoelectron response
    # and the uncertainties of the mean
    mean_psi = (mean_s - mean_b) / occupancy
    var_psi = (var_s - var_b) / occupancy - mean_psi**2
    mean_psi_stat_err = (occupancy * (mean_psi**2 + var_psi) + 2 * var_b) / (tot_b * occupancy**2) + (
            mean_psi * mean_psi * (np.exp(occupancy) + 1 - 2 * f_b)) / (f_b * tot_b * occupancy**2)
    mean_psi_sys_err = (mean_s - mean_b) * occupancy_err / (occupancy**2)
    mean_psi_err = np.sqrt(mean_psi_stat_err**2 + mean_psi_sys_err**2)

    gain_estimator = {&#39;moments_s&#39;: moments_s, &#39;moments_b&#39;: moments_b,
                      &#39;mean_psi&#39;: mean_psi, &#39;variance_psi&#39;: var_psi,
                      &#39;mean_psi_stat_err&#39;: mean_psi_stat_err, &#39;mean_psi_sys_err&#39;: mean_psi_sys_err,
                      &#39;mean_psi_err&#39;: mean_psi_err}

    return gain_estimator</code></pre>
</details>
</dd>
<dt id="pmt_analysis.analysis.model_independent.GainModelIndependent.get_occupancy_model_independent"><code class="name flex">
<span>def <span class="ident">get_occupancy_model_independent</span></span>(<span>self, areas_led_on: numpy.ndarray, areas_led_off: numpy.ndarray) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the occupancy for the model independent gain calculation.</p>
<p>For a range of thresholds within the 0PE peak areas, calculate the number of entries
below threshold for 'LED off' (<code>integral_b</code>) and 'LED on' (<code>integral_s</code>) data areas.
The occupancy can be estimated from the number of 'LED on' sample triggers with
zero LED-induced photoelectrons, as can be assumed for a sufficiently low threshold
for <code>integral_s</code>, and the total number of sample triggers, as can be by proportion estimated
through <code>integral_b</code>. As the number of photoelectrons produced follows a Poisson distribution,
we can use the expression <code>-ln(integral_s/integral_b)</code> as an estimator for the occupancy for the
selected threshold. This threshold is supposed to be sufficiently low such that <code>integral_s</code> is
not contaminated by a significant 1PE contribution. We therefore try to find the lowest
threshold for which sufficient data points are available below threshold to achieve a
relative occupancy error of below 1%. Ideally this is located in a local and global
maximum plateau around / slightly below zero areas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>areas_led_on</code></strong></dt>
<dd>Array with 'LED on' data pulse areas.</dd>
<dt><strong><code>areas_led_off</code></strong></dt>
<dd>Array with 'LED off' data pulse areas.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>occupancy_estimator</code></dt>
<dd>Dictionary with the following keys:
{'occupancy': final occupancy estimate;
'occupancy_err': uncertainty final occupancy estimate;
'threshold_occupancy_determination': threshold in 0PE peak area calculations
for final occupancy estimate;
'thr_occ_det_integral_fraction': fraction of entries in 'LED off' data below threshold;
'tot_entries_b': total number of waveforms in 'LED off' data,
'iterations': dictionary with the tested thresholds and corresponding
occupancy, occupancy uncertainty, and smoothed occupancy values}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_occupancy_model_independent(self, areas_led_on: np.ndarray, areas_led_off: np.ndarray) -&gt; dict:
    &#34;&#34;&#34;Calculate the occupancy for the model independent gain calculation.

    For a range of thresholds within the 0PE peak areas, calculate the number of entries
    below threshold for &#39;LED off&#39; (`integral_b`) and &#39;LED on&#39; (`integral_s`) data areas.
    The occupancy can be estimated from the number of &#39;LED on&#39; sample triggers with
    zero LED-induced photoelectrons, as can be assumed for a sufficiently low threshold
    for `integral_s`, and the total number of sample triggers, as can be by proportion estimated
    through `integral_b`. As the number of photoelectrons produced follows a Poisson distribution,
    we can use the expression `-ln(integral_s/integral_b)` as an estimator for the occupancy for the
    selected threshold. This threshold is supposed to be sufficiently low such that `integral_s` is
    not contaminated by a significant 1PE contribution. We therefore try to find the lowest
    threshold for which sufficient data points are available below threshold to achieve a
    relative occupancy error of below 1%. Ideally this is located in a local and global
    maximum plateau around / slightly below zero areas.

    Args:
        areas_led_on: Array with &#39;LED on&#39; data pulse areas.
        areas_led_off: Array with &#39;LED off&#39; data pulse areas.

    Returns:
        occupancy_estimator: Dictionary with the following keys:
            {&#39;occupancy&#39;: final occupancy estimate;
            &#39;occupancy_err&#39;: uncertainty final occupancy estimate;
            &#39;threshold_occupancy_determination&#39;: threshold in 0PE peak area calculations
                for final occupancy estimate;
            &#39;thr_occ_det_integral_fraction&#39;: fraction of entries in &#39;LED off&#39; data below threshold;
            &#39;tot_entries_b&#39;: total number of waveforms in &#39;LED off&#39; data,
            &#39;iterations&#39;: dictionary with the tested thresholds and corresponding
                occupancy, occupancy uncertainty, and smoothed occupancy values}
    &#34;&#34;&#34;
    # Total number of waveforms in &#39;LED off&#39; data
    tot_entries_b = areas_led_off.shape[0]

    # Define list of thresholds to probe in iterative occupancy determination
    if self.outliers_thresholds[0] is None:
        thr_it_occ_det = np.abs(self.get_outlier_bounds(areas_led_on)[0])
    else:
        thr_it_occ_det = np.abs(self.outliers_thresholds[0])
    lower_thr_it_occ_det = - thr_it_occ_det / 2
    upper_thr_it_occ_det = thr_it_occ_det / 2
    list_thr_it_occ_det = np.arange(lower_thr_it_occ_det, upper_thr_it_occ_det + 1)

    # Initialize lists for resulting occupancies as a function of threshold.
    # Use lists with append as it showed to be faster than np.arrays in this application.
    occupancy_list = list()
    occupancy_err_list = list()
    thresholds_list = list()
    f_list = list()

    # Loop over thresholds and calculate corresponding occupancy and error
    for threshold in list_thr_it_occ_det:
        # Calculate number of entries below peak area threshold for &#39;LED off&#39; (integral_b) and
        # &#39;LED on&#39; (integral_s) data. Correction factor on integral_b (and later also f) should
        # be close to one and only correct for differences due to outlier removal.
        # If significantly different cardinalities of LED on and off data sets are used,
        # the error calculation below may become incorrect.
        integral_b = np.sum(areas_led_off &lt; threshold) * len(areas_led_on) / len(areas_led_off)
        integral_s = np.sum(areas_led_on &lt; threshold)

        # Perform occupancy calculations only for positive number of entries below threshold
        if integral_b &gt; 0 and integral_s &gt; 0:
            # Fraction of entries in &#39;LED off&#39; data below threshold
            f = integral_b / (tot_entries_b * len(areas_led_on) / len(areas_led_off))
            # The occupancy can be estimated from the number of &#39;LED on&#39; sample triggers with zero LED-induced
            # photoelectrons, as can be assumed for a sufficiently low threshold for integral_s, and the
            # total number of sample triggers, as can be by proportion estimated through integral_b.
            # As the number of photoelectrons produced follows a Poisson distribution, we can use the following
            # expression as an estimator for the occupancy for the selected threshold (which, if sufficiently low
            # to not be contaminated by a significant 1PE contribution,
            # should not change the obtained occupancy value).
            l_val = -np.log(integral_s / integral_b)
            l_err = np.sqrt((np.exp(l_val) + 1. - 2. * f) / integral_b)

            # Only consider occupancy values with relative uncertainties below 5%.
            if l_err / l_val &lt;= 0.05:
                occupancy_list.append(l_val)
                occupancy_err_list.append(l_err)
                thresholds_list.append(threshold)
                f_list.append(f)

    if len(occupancy_list) == 0:
        raise ValueError(&#39;No occupancy values determined in threshold iterations.&#39;)

    # Convert to numpy arrays
    occupancy_list = np.asarray(occupancy_list)
    occupancy_err_list = np.asarray(occupancy_err_list)
    thresholds_list = np.asarray(thresholds_list)
    f_list = np.asarray(f_list)

    # Smooth threshold-dependent occupancies with Savitzky–Golay filter
    occupancy_list_smooth = self.sav_gol_smoothing(occupancy_list)

    # Sort indices in smoothed occupancy list by their element value in descending order
    occupancy_list_smooth_argsort = occupancy_list_smooth.argsort()[::-1]

    # Find threshold and corresponding occupancy for highest smoothed occupancy value
    # for which the relative occupancy error is below 1%.
    # Ideally this is located in a local and global maximum plateau around / slightly below zero areas
    # where 1PE contributions are negligible but on the other hand sufficient data points are available
    # below the threshold to bring the relative uncertainty down to the required level.
    # If no threshold value fulfils this criterion, return NaN occupancy.
    occupancy_estimate = np.nan
    occupancy_estimate_err = np.nan
    threshold_occ_det = np.nan
    thr_occ_det_integral_fraction = np.nan
    for idx in occupancy_list_smooth_argsort:
        if occupancy_err_list[idx] / occupancy_list[idx] &lt; 0.01:
            occupancy_estimate = occupancy_list[idx]
            occupancy_estimate_err = occupancy_err_list[idx]
            threshold_occ_det = thresholds_list[idx]
            thr_occ_det_integral_fraction = f_list[idx]
            break

    if np.isnan(occupancy_estimate):
        warnings.warn(&#39;Failed to estimate occupancy with the required precision. Returned NaN.&#39;)
    elif occupancy_estimate &lt;= 0:
        warnings.warn(&#39;Warning: Estimated occupancy ({:.3f} ± {:.3f}) seems to be &#39;
                      &#39;less than zero.&#39;.format(occupancy_estimate, occupancy_estimate_err))
    elif self.verbose:
        print(&#39;Threshold for occupancy estimation: {}&#39;.format(threshold_occ_det))
        print(&#39;Estimated occupancy: {:.3f} ± {:.3f}&#39;.format(occupancy_estimate, occupancy_estimate_err))

    occupancy_estimator = {&#39;occupancy&#39;: occupancy_estimate,
                           &#39;occupancy_err&#39;: occupancy_estimate_err,
                           &#39;threshold_occupancy_determination&#39;: threshold_occ_det,
                           &#39;thr_occ_det_integral_fraction&#39;: thr_occ_det_integral_fraction,
                           &#39;tot_entries_b&#39;: tot_entries_b,
                           &#39;iterations&#39;: {&#39;threshold&#39;: thresholds_list,
                                          &#39;occupancy&#39;: occupancy_list,
                                          &#39;occupancy_err&#39;: occupancy_err_list,
                                          &#39;occupancy_smoothed&#39;: occupancy_list_smooth},
                           }

    return occupancy_estimator</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pmt_analysis.analysis" href="index.html">pmt_analysis.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent" href="#pmt_analysis.analysis.model_independent.GainModelIndependent">GainModelIndependent</a></code></h4>
<ul class="">
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.compute" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.compute">compute</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.get_area_histogram" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.get_area_histogram">get_area_histogram</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.get_gain_model_independent" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.get_gain_model_independent">get_gain_model_independent</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.get_moments" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.get_moments">get_moments</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.get_occupancy_model_independent" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.get_occupancy_model_independent">get_occupancy_model_independent</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.get_outlier_bounds" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.get_outlier_bounds">get_outlier_bounds</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.inputs_to_numpy" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.inputs_to_numpy">inputs_to_numpy</a></code></li>
<li><code><a title="pmt_analysis.analysis.model_independent.GainModelIndependent.sav_gol_smoothing" href="#pmt_analysis.analysis.model_independent.GainModelIndependent.sav_gol_smoothing">sav_gol_smoothing</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>